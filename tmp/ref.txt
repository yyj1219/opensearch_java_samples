import org.opensearch.client.json.JsonData;
import org.opensearch.client.opensearch.OpenSearchClient;
import org.opensearch.client.opensearch._types.ExpandWildcard;
import org.opensearch.client.opensearch._types.query_dsl.*;
import org.opensearch.client.opensearch.core.SearchRequest;
import org.opensearch.client.opensearch.core.SearchResponse;
import org.opensearch.client.opensearch.core.search.*;
import org.opensearch.client.opensearch._types.SortOrder;
import org.opensearch.client.opensearch._types.FieldValue;
import org.opensearch.client.opensearch.core.search.Hit;

import scouter.config.CommonConfigure;
import scouter.db.elastic.metering.XLogHistoMetering;
import scouter.db.elastic.vo.HeatMapBucket;
import scouter.db.elastic.vo.XLogHistoVo;
import scouter.lang.TextTypes;
import scouter.lang.args.TopTxSearchArgs;
import scouter.lang.args.XLogInfoSearchArgs;
import scouter.lang.counters.E2ETypeConstants;
import scouter.server.Logger;
import scouter.server.util.QueryUtil;
import scouter.util.DateUtil;
import tuna.server.db.common.DateHistogramIntervalManager;
import tuna.server.db.common.TextSearchHelper;
import tuna.server.db.common.TextSearchInfo;
import tuna.server.db.common.elastic.ConnectionManager;
import tuna.server.db.common.opensearch.OpenSearchConnectionManager;
import tuna.server.db.rd.IEndUserTxRD;
import tuna.server.db.rd.factory.TextRDFactory;
import tuna.server.text.cache.LocalTextCache;

import java.io.IOException;
import java.text.NumberFormat;
import java.time.ZoneId;
import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

public class EndUserTxOschRD implements IEndUserTxRD {

    private CommonConfigure conf;
    private final int XLOG_HISTO_TIME_BUCKETS = 150;
    private TextSearchHelper textSearchHelper;

    public EndUserTxOschRD()  {
        conf = CommonConfigure.getInstance();
        textSearchHelper = TextSearchHelper.getInstance();
    }

    public List<Map<String, Object>> LoadEndUserXLogInfo(XLogInfoSearchArgs args) {
        try {
            List<String> timeList = DateUtil.getSearchRangeTime("enduser-info-", args.from, args.to);
            if (timeList == null) return null;

            String[] indexes = timeList.toArray(new String[timeList.size()]);

            if (args.toElapsed == -1) {
                args.toElapsed = Integer.MAX_VALUE;
            }

            List<Query> filterQueries = new ArrayList<>();
            filterQueries.add(RangeQuery.of(r -> r.field("endTime").gte(JsonData.of(args.from)).lte(JsonData.of(args.to))).toQuery());
            filterQueries.add(RangeQuery.of(r -> r.field("elapsedTime").gte(JsonData.of(args.fromElapsed)).lte(JsonData.of(args.toElapsed))).toQuery());
            List<FieldValue> objHashValues = args.objList.stream().map(FieldValue::of).collect(Collectors.toList());
            filterQueries.add(TermsQuery.of(t -> t.field("objHash").terms(tqf -> tqf.value(objHashValues))).toQuery());

            if (args.serviceHash != 0L) {
                filterQueries.add(TermQuery.of(t -> t.field("serviceHash").value(FieldValue.of(args.serviceHash))).toQuery());
            }

            List<Query> mustNotQueries = new ArrayList<>();
            mustNotQueries.add(TermQuery.of(t -> t.field("type").value(FieldValue.of(E2ETypeConstants.ERROR))).toQuery());

            Map<String, Object> filters = args.fileterMap;
            for (Map.Entry<String, Object> entry : filters.entrySet()) {
                String key = entry.getKey();
                Object value = entry.getValue();
                if (key.equals("elapsed")) {
                    filterQueries.add(RangeQuery.of(r -> r.field("elapsedTime").gte(JsonData.of(value))).toQuery());
                } else if (key.equals("error")) {
                    mustNotQueries.add(TermQuery.of(t -> t.field("errorHash").value(FieldValue.of(0))).toQuery());
                } else {
                    List<FieldValue> values = new ArrayList<>();
                    if (value instanceof Integer) {
                        values = List.of(FieldValue.of((Integer) value));
                    } else if (value instanceof Long) {
                        values = List.of(FieldValue.of((Long) value));
                    } else if (value instanceof String) {
                        values = List.of(FieldValue.of(value.toString()));
                    } else if (value instanceof List) {
                        List<Object> valueList = (List<Object>) value;
                        for (Object obj : valueList) {
                            if (obj instanceof Integer) {
                                values.add(FieldValue.of((Integer) obj));
                            } else if (obj instanceof Long) {
                                values.add(FieldValue.of((Long) obj));
                            } else if (obj instanceof String) {
                                values.add(FieldValue.of(obj.toString()));
                            }
                        }
                    }
                    List<FieldValue> finalValues = values;
                    filterQueries.add(TermsQuery.of(t -> t.field(key).terms(tqf -> tqf.value(finalValues))).toQuery());
                }
            }

            BoolQuery.Builder boolQueryBuilder = new BoolQuery.Builder().filter(filterQueries).mustNot(mustNotQueries);

            String order;
            SortOrder orderCmd;
            if ((args.order != null) && (!args.order.isEmpty())) {
                order = args.order;
            } else {
                order = "elapsedTime";
            }
            if ((args.orderCmd != null) && (args.orderCmd.equals("asc"))) {
                orderCmd = SortOrder.Asc;
            } else {
                orderCmd = SortOrder.Desc;
            }

            List<String> docValueFields = Arrays.asList(
                    "domProcessingTime", "elapsedTime", "endTime", "errorHash", "networkTime",
                    "objHash", "objName", "serverTime", "serviceHash", "timeToDomComplete",
                    "timeToDomInteracitve", "loadTime", "connectionTime", "sslConnectionTime",
                    "dnsLookupTime", "timeToFirstByteRecv", "type", "userIp", "gxid",
                    "agentHash", "pageProcessingTime", "os", "browser", "uuid"
            );

            SearchRequest request = SearchRequest.of(s -> s
                    .index(Arrays.asList(indexes))
                    .query(boolQueryBuilder.build().toQuery())
                    .sort(so -> so.field(f -> f.field(order).order(orderCmd)))
                    .size(conf.es_query_fetch_size)
                    .source(SourceConfig.of(sc -> sc.fetch(false)))
                    .docvalueFields(docValueFields.stream()
                            .map(field -> FieldAndFormat.of(f -> f.field(field)))
                            .collect(Collectors.toList()))
                    .ignoreUnavailable(true)
                    .allowNoIndices(true)
                    .expandWildcards(ExpandWildcard.Open)
            );

            if (conf.print_es_query) {
                Logger.println(request.toString());
            }

            OpenSearchClient client = Objects.requireNonNull(OpenSearchConnectionManager.getInstance()).getReadClient();
            SearchResponse<Map> searchResponse = client.search(request, Map.class);

            List<Map<String, Object>> resultList = new ArrayList<>();
            TextSearchInfo textSearchInfo = new TextSearchInfo();

            for (Hit<Map> hit : searchResponse.hits().hits()) {
                Map<String, Object> valueMap = new HashMap<>();
                for (Map.Entry<String, JsonData> field : hit.fields().entrySet()) {
                    String fieldName = field.getKey();
                    switch (fieldName) {
                        case "endTime":
                            valueMap.put("endTime", field.getValue().to(Long.class));
                            break;
                        case "serviceHash":
                            int serviceHash = field.getValue().to(Integer.class);
                            valueMap.put(fieldName, serviceHash);
                            valueMap.put("service", textSearchHelper.searchText(textSearchInfo, TextTypes.SERVICE, serviceHash));
                            break;
                        case "errorHash":
                            int errorHash = field.getValue().to(Integer.class);
                            valueMap.put("error", errorHash);
                            valueMap.put("errorMsg", textSearchHelper.searchText(textSearchInfo, TextTypes.ERROR, errorHash));
                            break;
                        default:
                            valueMap.put(fieldName, JsonData.of(field.getValue().to(Object.class)));
                            break;
                    }
                }
                long endTime = Long.parseLong(valueMap.get("endTime").toString());
                int elapsed = Integer.parseInt(valueMap.get("elapsedTime").toString());
                valueMap.put("startTime", endTime - elapsed);
                resultList.add(valueMap);
            }

            LocalTextCache localTextCache = null;
            if (textSearchInfo.getSize() > 0) {
                localTextCache = TextOschRD.getInstance().getString(textSearchInfo);
                if (localTextCache != null) {
                    for (Map<String, Object> map : resultList) {
                        if (map.get("serviceHash") != null && map.get("service") == null) {
                            map.put("service", localTextCache.get(TextTypes.SERVICE, Integer.parseInt(map.get("serviceHash").toString())));
                        }
                        if (map.get("error") != null && map.get("errorMsg") == null) {
                            map.put("errorMsg", localTextCache.get(TextTypes.ERROR, Integer.parseInt(map.get("error").toString())));
                        }
                    }
                }
            }

            if (conf.print_es_query_result) {
                QueryUtil.print(resultList);
            }
            return resultList;
        } catch (IOException ex) {
            Logger.println(ex);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        return null;
    }
}
